// --------------------------------------------------------------------------------------------------------------------
// <copyright file="HandlerFactory.cs" company="Naos">
//    Copyright (c) Naos 2017. All Rights Reserved.
// </copyright>
// <auto-generated>
//   Sourced from NuGet package. Will be overwritten with package update except in Naos.MessageBus.Console.Bootstrapper source.
// </auto-generated>
// --------------------------------------------------------------------------------------------------------------------

#if NaosMessageBusHangfireConsole
namespace Naos.MessageBus.Hangfire.Console
#else
namespace Naos.FileJanitor.MessageBus.Hangfire.Console
#endif
{
    using System;
    using System.Collections.Generic;
    using System.Threading.Tasks;

    using Its.Log.Instrumentation;

    using Naos.FileJanitor.MessageBus.Handler;
    using Naos.FileJanitor.MessageBus.Scheduler;
    using Naos.MessageBus.Domain;

    using static System.FormattableString;

    /// <summary>
    /// Factory builder to provide logic to resolve the appropriate <see cref="IHandleMessages" /> for a dispatched <see cref="IMessage" /> implementation.
    /// </summary>
    public static partial class HandlerFactory
    {
        /*----------------------------- CHANGE HERE ---------------------------------*
         * Specify explicit mapping here, if no types are RENAME this file    *
         * in the Dictionary (Message->Handler Types) then the reflection only *
         * Factory will be used, if there are types specified then ONLY those and    *
         * built in ones will be used.                                               *
         *---------------------------------------------------------------------------*/

        /// <summary>
        /// Map of the message type to the intended handler type.  Must have a parameterless constructor and implement <see cref="IHandleMessages" />,
        /// however deriving from <see cref="MessageHandlerBase{T}" /> is recommended as it's more straightforward and easier to write.
        /// </summary>
        private static readonly IReadOnlyDictionary<Type, Type> MessageTypeToHandlerTypeMap = new Dictionary<Type, Type>
                                                                                                  {
                                                                                                      { typeof(ArchiveDirectoryMessage), typeof(ArchiveDirectoryMessageHandler) },
                                                                                                      { typeof(AbortIfNoNewFileLocationForTopicMessage), typeof(AbortIfNoNewFileLocationForTopicMessageHandler) },
                                                                                                      { typeof(CleanupDirectoryMessage), typeof(CleanupDirectoryMessageHandler) },
                                                                                                      { typeof(DeleteFileMessage), typeof(DeleteFileMessageHandler) },
                                                                                                      { typeof(FetchFileMessage), typeof(FetchFileFromS3MessageHandler) },
                                                                                                      { typeof(FindFileMessage), typeof(FindFileInS3MessageHandler) },
                                                                                                      { typeof(ShareFileLocationMessage), typeof(ShareFileLocationMessageHandler) },
                                                                                                      { typeof(ShareFilePathMessage), typeof(ShareFilePathMessageHandler) },
                                                                                                      { typeof(ShareUserDefinedMetadataMessage), typeof(ShareUserDefinedMetadataMessageHandler) },
                                                                                                      { typeof(StoreFileMessage), typeof(StoreFileInS3MessageHandler) },
                                                                                                  };
    }

    /// <summary>
    /// Example of an <see cref="IMessage" />.
    /// </summary>
    public class ExampleMessage : IMessage
    {
        /// <inheritdoc cref="IMessage" />
        public string Description { get; set; }

        /// <summary>
        /// Gets or sets an example of a group of work to process.
        /// </summary>
        public string GroupToProcess { get; set; }
    }

    /// <summary>
    /// Handler for <see cref="ExampleMessage" />.
    /// </summary>
    public class ExampleMessageHandler : MessageHandlerBase<ExampleMessage>
    {
        /// <inheritdoc cref="MessageHandlerBase{T}" />
        public override async Task HandleAsync(ExampleMessage message)
        {
            await Task.Run(() => { });

            Log.Write(() => Invariant($"Finished processing group: {message.GroupToProcess}"));
        }
    }
}